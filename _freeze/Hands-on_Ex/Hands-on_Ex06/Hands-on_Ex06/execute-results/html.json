{
  "hash": "8a0b7f9e04b4f4e8b62dc3c85c9aa1a0",
  "result": {
    "markdown": "---\ntitle: \"Hands-on Exercise 6\"\nsubtitle: \"Visualising & Analysing Time-oriented Data\"\ndate: \"1 February 2024\"\ndate-modified: \"last-modified\"\nauthor: \"Teo Suan Ern\"\nexecute: \n  eval: true\n  echo: true\n  freeze: true\n  warning: false\n  message: false\n---\n\n\n*Note: Last modified to include author’s details.*\n\n# 1. Getting Started\n\nThis exercise will over on the following:\n\n-   plotting a calender heatmap by using **ggplot2** functions,\n\n-   plotting a cycle plot by using **ggplot2** function,\n\n-   plotting a slopegraph\n\n-   plotting a horizon chart\n\n## 1.1 Install and launch R packages\n\nFor the purpose of this exercise, the following R packages will be used.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show code\"}\npacman::p_load(scales, viridis, lubridate, ggthemes, gridExtra, readxl, \n               knitr, data.table, CGPfunctions, ggHoriPlot, tidyverse)\n```\n:::\n\n\n## 1.2 Import the data\n\nThis exercise used the ***eventlog.csv*** dataset.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show code\"}\nattacks <- read_csv(\"data/eventlog.csv\")\n```\n:::\n\n\n## 1.3 Examine data structure\n\n*kable()* can be used to review the structure of the imported data frame.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show code\"}\nkable(head(attacks))\n```\n\n::: {.cell-output-display}\n|timestamp           |source_country |tz              |\n|:-------------------|:--------------|:---------------|\n|2015-03-12 15:59:16 |CN             |Asia/Shanghai   |\n|2015-03-12 16:00:48 |FR             |Europe/Paris    |\n|2015-03-12 16:02:26 |CN             |Asia/Shanghai   |\n|2015-03-12 16:02:38 |US             |America/Chicago |\n|2015-03-12 16:03:22 |CN             |Asia/Shanghai   |\n|2015-03-12 16:03:45 |CN             |Asia/Shanghai   |\n:::\n:::\n\n\nThere are three columns, namely *timestamp*, *source_country* and *tz*.\n\n-   *timestamp* field stores date-time values in POSIXct format.\n\n-   *source_country* field stores the source of the attack. It is in *ISO 3166-1 alpha-2* country code.\n\n-   *tz* field stores time zone of the source IP address.\n\n## 1.4 Data Preparation\n\n### Step 1: Deriving *weekday* and *hour of day* fields\n\nDerive two new fields namely *wkday* and *hour* before plotting the calendar heatmap, **by writing a `function()` to perform the task**.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show code\"}\nmake_hr_wkday <- function(ts, sc, tz) {\n  real_times <- ymd_hms(ts, \n                        tz = tz[1], \n                        quiet = TRUE)\n  dt <- data.table(source_country = sc,\n                   wkday = weekdays(real_times),\n                   hour = hour(real_times))\n  return(dt)\n  }\n```\n:::\n\n\n::: {.callout-note icon=\"false\"}\n### Note\n\n-   `ymd_hms()` and `hour()` are from **lubridate** package, and\n\n-   `weekdays()` is a **base** R function.\n:::\n\n### Step 2: Deriving the attacks tibble data frame\n\nBeside extracting the necessary data into *attacks* data frame, `mutate()` of **dplyr** package is used to convert *wkday* and *hour* fields into **factor** so they’ll be ordered when plotting.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show code\"}\nwkday_levels <- c('Saturday', 'Friday', \n                  'Thursday', 'Wednesday', \n                  'Tuesday', 'Monday', \n                  'Sunday')\n\nattacks <- attacks %>%\n  group_by(tz) %>%\n  do(make_hr_wkday(.$timestamp, \n                   .$source_country, \n                   .$tz)) %>% \n  ungroup() %>% \n  mutate(wkday = factor(\n    wkday, levels = wkday_levels),\n    hour  = factor(\n      hour, levels = 0:23))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show code\"}\nkable(head(attacks))\n```\n\n::: {.cell-output-display}\n|tz           |source_country |wkday    |hour |\n|:------------|:--------------|:--------|:----|\n|Africa/Cairo |BG             |Saturday |20   |\n|Africa/Cairo |TW             |Sunday   |6    |\n|Africa/Cairo |TW             |Sunday   |8    |\n|Africa/Cairo |CN             |Sunday   |11   |\n|Africa/Cairo |US             |Sunday   |15   |\n|Africa/Cairo |CA             |Monday   |11   |\n:::\n:::\n\n\n# 2. Plotting Calendar Heatmap\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show code\"}\ngrouped <- attacks %>% \n  count(wkday, hour) %>% \n  ungroup() %>%\n  na.omit()\n\nggplot(grouped, \n       aes(hour, \n           wkday, \n           fill = n)) + \ngeom_tile(color = \"white\", \n          size = 0.1) + \ntheme_tufte(base_family = \"Helvetica\") + \ncoord_equal() +\nscale_fill_gradient(name = \"# of attacks\",\n                    low = \"sky blue\", \n                    high = \"dark blue\") +\nlabs(x = NULL, \n     y = NULL, \n     title = \"Attacks by weekday and time of day\") +\ntheme(axis.ticks = element_blank(),\n      plot.title = element_text(hjust = 0.5),\n      legend.title = element_text(size = 8),\n      legend.text = element_text(size = 6) )\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex06_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\n::: {.callout-note icon=\"false\"}\n### Learning Points\n\n-   a tibble data table called *grouped* is derived by aggregating the attack by *wkday* and *hour* fields.\n\n-   a new field called *n* is derived by using `group_by()` and `count()` functions.\n\n-   `na.omit()` is used to exclude missing value.\n\n-   `geom_tile()` is used to plot tiles (grids) at each x and y position. `color` and `size` arguments are used to specify the border color and line size of the tiles.\n\n-   `theme_tufte()` of **ggthemes** package is used to remove unnecessary chart junk. To learn which visual components of default ggplot2 have been excluded, you are encouraged to comment out this line to examine the default plot.\n\n-   `coord_equal()` is used to ensure the plot will have an aspect ratio of 1:1.\n\n-   `scale_fill_gradient()` function is used to creates a two colour gradient (low-high).\n:::\n\n# 3. Plotting Multiple Calendar Heatmaps\n\n### Step 1: Deriving attack by country object\n\nIn order to identify the top four countries with the highest number of attacks, the following have to be done:\n\n-   count the number of attacks by country,\n\n-   calculate the percent of attackes by country, and\n\n-   save the results in a tibble data frame.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Show code\"}\n    attacks_by_country <- count(\n      attacks, source_country) %>%\n      mutate(percent = percent(n/sum(n))) %>%\n      arrange(desc(n))\n    ```\n    :::\n\n\n### Step 2: Preparing the tidy data frame\n\nExtract the attack records of the top four countries from attacks data frame and save the data in a new tibble data frame (i.e. *top4_attacks*).\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show code\"}\n# extracts top 4 source countries & save as top4\ntop4 <- attacks_by_country$source_country[1:4] \n\ntop4_attacks <- attacks %>%\n  # filter attack dataset to include only rows from top4\n  filter(source_country %in% top4) %>% \n  count(source_country, wkday, hour) %>%\n  \n  # remove previous grouping from previous code action\n  ungroup() %>%\n  \n  # convert variable 'source_country' to factor from top4\n  mutate(source_country = factor(\n    source_country, levels = top4)) %>%\n  \n  # remove rows with missing values\n  na.omit()\n```\n:::\n\n\n### Step 3: Plotting multiple calendar heatmap\n\nUse `ggplot2` package to plot multiple calendar heatmaps.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show code\"}\nggplot(top4_attacks, \n       aes(hour, \n           wkday, \n           fill = n)) + \n  geom_tile(color = \"white\", \n          size = 0.1) + \n  theme_tufte(base_family = \"Helvetica\") + \n  coord_equal() +\n  scale_fill_gradient(name = \"# of attacks\",\n                    low = \"sky blue\", \n                    high = \"dark blue\") +\n  facet_wrap(~source_country, ncol = 2) +\n  labs(x = NULL, y = NULL, \n     title = \"Attacks on top 4 countries by weekday and time of day\") +\n  theme(axis.ticks = element_blank(),\n        axis.text.x = element_text(size = 7),\n        plot.title = element_text(hjust = 0.5),\n        legend.title = element_text(size = 8),\n        legend.text = element_text(size = 6) )\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex06_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\n# 4. Plotting Cycle Plot\n\n### Step 1: Importing data\n\nThe code chunk below imports *arrivals_by_air.xlsx* by using `read_excel()` of **readxl** package and save it as a tibble data frame called *air*.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show code\"}\nair <- read_excel(\"data/arrivals_by_air.xlsx\")\n```\n:::\n\n\n### Step 2: Deriving month and year fields\n\nTwo new fields called *month* and *year* are derived from *Month-Year* field.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show code\"}\nair$month <- factor(month(air$`Month-Year`), \n                    levels=1:12, \n                    labels=month.abb, \n                    ordered=TRUE) \nair$year <- year(ymd(air$`Month-Year`))\n```\n:::\n\n\n### Step 3: Extracting the target country\n\nFor effective data visualisation design, use `as.factor()` to convert the value type of Year field from numeric to factor.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show code\"}\nVietnam <- air %>% \n  select(`Vietnam`, \n         month, \n         year) %>%\n  filter(year >= 2010) %>%\n  mutate(year = as.factor(year))\n```\n:::\n\n\n### Step 4: Computing year average arrivals by month\n\nThe code chunk below uses `group_by()` and `summarise()` of **dplyr** to compute year average arrivals by month.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show code\"}\nhline.data <- Vietnam %>% \n  group_by(month) %>%\n  summarise(avgvalue = mean(`Vietnam`))\n```\n:::\n\n\n### Step 5: Plotting cycle plot\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show code\"}\nggplot() + \n  geom_line(data=Vietnam,\n            aes(x=year, \n                y=`Vietnam`, \n                group=month), \n            colour=\"black\") +\n  geom_hline(aes(yintercept=avgvalue), \n             data=hline.data, \n             linetype=6, \n             colour=\"red\", \n             size=0.5) + \n  facet_grid(~month) +\n  theme(axis.text.x = element_text(angle = 90, size = 4),\n        panel.grid = element_blank()) +\n  labs(axis.text.x = element_blank(),\n       title = \"Visitor arrivals from Vietnam by air, Jan 2010-Dec 2019\") +\n  xlab(\"\") +\n  ylab(\"No. of Visitors\")\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex06_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n:::\n\n\n# 5. Plotting Slopegraph\n\n### Step 1: Importing data\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show code\"}\nrice <- read_csv(\"data/rice.csv\")\n```\n:::\n\n\n### Step 2: Plotting slopegraph\n\nFor effective data visualisation design, use `factor()` to convert the value type of Year field from numeric to factor.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show code\"}\nrice %>% \n  mutate(Year = factor(Year)) %>%\n  filter(Year %in% c(1961, 1980)) %>%\n  newggslopegraph(Year, Yield, Country,\n                Title = \"Rice Yield of Top 11 Asian Counties\",\n                SubTitle = \"1961-1980\",\n                Caption = \"Data Source: Rice Yield\")\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex06_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n:::\n\n\n# 6. References\n\n[17 Visualising & Analysing Time-oriented Data](https://r4va.netlify.app/chap17){target=\"_blank\"}\n",
    "supporting": [
      "Hands-on_Ex06_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}